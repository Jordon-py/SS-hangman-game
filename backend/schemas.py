"""
Pydantic models defining request and response shapes for the API.

These models document and validate the structure of data exchanged
between the client and server. Using Pydantic helps catch malformed
payloads early and produces clear error messages for API consumers.
"""

from __future__ import annotations

from datetime import datetime
from typing import Any, Dict, Optional

from pydantic import BaseModel, Field


class JobSettings(BaseModel):
    """Settings controlling how the mastering job will run."""

    preset: str = Field(default="hi_fi_streaming", description="Name of the mastering preset.")
    enable_demucs: bool = Field(default=False, description="Reserved flag for stem separation pipeline.")
    mono_sub: bool = Field(default=False, description="Mono-anchor low frequencies below ~120 Hz.")
    dynamic_eq: bool = Field(default=False, description="Masking-aware dynamic EQ in the 200-500 Hz band.")
    truepeak_limiter: bool = Field(default=False, description="True-peak safer limiter + soft clip stage.")
    target_lufs: Optional[float] = Field(default=None, description="Desired integrated loudness estimate.")
    true_peak_ceiling: float = Field(default=-1.0, description="Limiter output ceiling in dBTP.")


class JobCreateResponse(BaseModel):
    id: str
    status: str
    settings: JobSettings


class JobStatusResponse(BaseModel):
    id: str
    status: str
    progress: float = Field(..., ge=0.0, le=100.0)
    created_at: datetime
    started_at: Optional[datetime] = None
    finished_at: Optional[datetime] = None
    error: Optional[str] = None
    settings: JobSettings


class JobReportResponse(BaseModel):
    report: Dict[str, Any]


class ErrorResponse(BaseModel):
    detail: str
    preset: str = Field(
        default="hi_fi_streaming",
        title="Preset",
        description="Name of the mastering preset to apply.",
    )
    enable_demucs: bool = Field(
        default=False,
        title="Enable Demucs Separation",
        description=(
            "If True, perform stem separation using HT-Demucs before mastering. "
            "This allows the algorithm to treat vocals, bass and drums separately."
        ),
    )
    mono_sub: bool = Field(
        default=True,
        title="Mono Sub",
        description="Enable mono sub summing to improve low-frequency focus.",
    )
    dynamic_eq: bool = Field(
        default=True,
        title="Dynamic Masking EQ",
        description="Activate the adaptive low-mid dip based on masking ratio.",
    )
    target_lufs: Optional[float] = Field(
        default=None,
        title="Target LUFS",
        description=(
            "Desired integrated loudness (in LUFS). If unspecified, the script will pick "
            "a sensible target based on the preset and loudness governor."
        ),
    )
    warmth: float = Field(
        default=0.0,
        title="Warmth",
        description="Analog-style warmth (tilt EQ) from 0.0 to 1.0 (100%).",
        ge=0.0,
        le=100.0,
    )


class JobCreateResponse(BaseModel):
    """Response returned when a job is created."""

    id: str = Field(..., title="Job ID")
    status: str = Field(..., title="Initial status")
    settings: JobSettings = Field(..., title="Echo of submitted settings")


class JobStatusResponse(BaseModel):
    """Representation of a running or finished job."""

    id: str = Field(..., title="Job ID")
    status: str = Field(..., title="Current status")
    progress: float = Field(..., title="Progress", ge=0.0, le=100.0)
    created_at: datetime = Field(..., title="Creation timestamp")
    started_at: Optional[datetime] = Field(None, title="Processing start timestamp")
    finished_at: Optional[datetime] = Field(None, title="Processing finished timestamp")
    error: Optional[str] = Field(None, title="Error message, if any")
    settings: JobSettings = Field(..., title="Echo of submitted settings")


class JobReportResponse(BaseModel):
    """Response containing the mastering report generated by the script."""

    report: Dict[str, Any] = Field(..., title="Arbitrary JSON report")


class ErrorResponse(BaseModel):
    """Standard error response shape."""

    detail: str = Field(..., title="Human-readable error message")
